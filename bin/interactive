#!/usr/bin/env bash

# * use `__CLEAN=1 zsh` to load a minimal environment, see notes below

# set title of prompt. c.f. https://tldp.org/HOWTO/Xterm-Title-3.html
echo -n "\033]0;${__HOST%%.*}\007"

# helpers ######################################################################

# * any path-like variables should be remember and reset using this machanism
# keeping the original PATH for cleaning environments
export __PATH="${__PATH:-$PATH}"
export __MANPATH="${__MANPATH:-$MANPATH}"
export __INFOPATH="${__INFOPATH:-$INFOPATH}"
export __PYTHONPATH="${__PYTHONPATH:-$PYTHONPATH}"
export __LD_LIBRARY_PATH="${__LD_LIBRARY_PATH:-$LD_LIBRARY_PATH}"
# reset PATH every time a new interactive shell is started
# berfore any paths are added to it
[[ -n "$__PATH" ]] && export PATH="$__PATH"
[[ -n "$__MANPATH" ]] && export MANPATH="$__MANPATH"
[[ -n "$__INFOPATH" ]] && export INFOPATH="$__INFOPATH"
[[ -n "$__PYTHONPATH" ]] && export PYTHONPATH="$__PYTHONPATH"
[[ -n "$__LD_LIBRARY_PATH" ]] && export LD_LIBRARY_PATH="$__LD_LIBRARY_PATH"

printerr () {
    printf "%s\\n" "$@" >&2
}

path_prepend () {
    if [[ -d "$1" ]]; then
        case ":$PATH:" in
            *":$1:"*) :;;
            *) export PATH="${1}${PATH:+:${PATH}}";;
        esac
    fi
}

path_append () {
    if [[ -d "$1" ]]; then
        case ":$PATH:" in
            *":$1:"*) :;;
            *) export PATH="${PATH:+${PATH}:}${1}";;
        esac
    fi
}

pythonpath_prepend () {
    if [[ -d "$1" ]]; then
        case ":$PYTHONPATH:" in
            *":$1:"*) :;;
            *) export PYTHONPATH="${1}${PYTHONPATH:+:${PYTHONPATH}}";;
        esac
    fi
}

pythonpath_append () {
    if [[ -d "$1" ]]; then
        case ":$PYTHONPATH:" in
            *":$1:"*) :;;
            *) export PYTHONPATH="${PYTHONPATH:+${PYTHONPATH}:}${1}";;
        esac
    fi
}

ld_library_path_prepend () {
    if [[ -d "$1" ]]; then
        case ":$LD_LIBRARY_PATH:" in
            *":$1:"*) :;;
            *) export LD_LIBRARY_PATH="${1}${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}";;
        esac
    fi
}

ld_library_path_append () {
    if [[ -d "$1" ]]; then
        case ":$LD_LIBRARY_PATH:" in
            *":$1:"*) :;;
            *) export LD_LIBRARY_PATH="${LD_LIBRARY_PATH:+${LD_LIBRARY_PATH}:}${1}";;
        esac
    fi
}

# variants of the above with $1 as the prefix only
# modifies PATH, MANPATH, INFOPATH
path_prepend_all () {
    if [[ -d "$1/bin" ]]; then
        case ":$PATH:" in
            *":$1/bin:"*) :;;
            *) export PATH="${1}/bin${PATH:+:${PATH}}";;
        esac
    fi
    if [[ -d "$1/share/man" ]]; then
        case ":$MANPATH:" in
            *":$1/share/man:"*) :;;
            *) export MANPATH="${1}/share/man${MANPATH:+:${MANPATH}}";;
        esac
    fi
    if [[ -d "$1/share/info" ]]; then
        case ":$INFOPATH:" in
            *":$1/share/info:"*) :;;
            *) export INFOPATH="${1}/share/info${INFOPATH:+:${INFOPATH}}";;
        esac
    fi
}

# TODO: fix this on FreeBSD such as bolo
path_append_all () {
    if [[ -d "$1/bin" ]]; then
        case ":$PATH:" in
            *":$1/bin:"*) :;;
            *) export PATH="${PATH:+${PATH}:}${1}/bin";;
        esac
    fi
    if [[ -d "$1/share/man" ]]; then
        case ":$MANPATH:" in
            *":$1/share/man:"*) :;;
            *) export MANPATH="${MANPATH:+${MANPATH}:}${1}/share/man";;
        esac
    fi
    if [[ -d "$1/share/info" ]]; then
        case ":$INFOPATH:" in
            *":$1/share/info:"*) :;;
            *) export INFOPATH="${INFOPATH:+${INFOPATH}:}${1}/share/info";;
        esac
    fi
}

# Powerlevel10k ################################################################

if [[ -n "$ZSH_VERSION" ]]; then

# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block, everything else may go below.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi
# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

fi

# "module" functions ###########################################################

# these should come in pairs of ml and mu stands for module-load, module-unload
# mu is not needed if it only manipulate PATH

# ! known limitation: this isn't truly a module unload system
# ! it probably still has side effects

ml_brew () {
    # adapted from `brew shellenv`
    export HOMEBREW_CELLAR="$HOMEBREW_PREFIX/Cellar"
    export HOMEBREW_REPOSITORY="$HOMEBREW_PREFIX/Homebrew"

    path_prepend "$HOMEBREW_PREFIX/sbin"
    path_prepend_all "$HOMEBREW_PREFIX"

    # TODO: remove this when all systems migrated away from GNU-ize
    # GNU-ize only needed on macOS
    if [[ "$__OSTYPE" == darwin && -s "$HOME/.path" ]]; then
        printerr "Deprecation notice: $HOME/.path will be ignored in the next release. This may be present if you used GNU-ize before."
        . "$HOME/.path"
    fi

    path_prepend_all "$HOMEBREW_PREFIX/opt/ruby"
}

mu_brew () {
    unset HOMEBREW_CELLAR
    unset HOMEBREW_REPOSITORY
    # TODO: remove this when all systems migrated away from GNU-ize
    # from "$HOME/.path"
    unset HOMEBREW_CC
    unset HOMEBREW_CXX
}

# macports
ml_port () {
    path_prepend /opt/local/sbin
    path_prepend_all /opt/local
    path_prepend /opt/local/libexec/gnubin
}

# conda
ml_conda () {
    # * this source the conda functions but not changing the PATH directly
    # it allows you to put the conda function available without letting it
    # changing your PATH
    local __PATH__="$PATH"
    . "$__CONDA_PREFIX/etc/profile.d/conda.sh"
    export PATH="$__PATH__"
}

mu_conda () {
    # from "$__CONDA_PREFIX/etc/profile.d/conda.sh"
    unset CONDA_EXE
    unset CONDA_PYTHON_EXE
    unset CONDA_SHLVL
    unset _CE_CONDA
    unset _CE_M
}

ml_basher () {
    if [[ -n "$ZSH_VERSION" ]]; then
        # basher init - zsh | sed "s:$HOME:\$HOME:g" | pbcopy
        export BASHER_SHELL=zsh
        export BASHER_ROOT=$HOME/.basher
        export BASHER_PREFIX=$HOME/.basher/cellar
        export BASHER_PACKAGES_PATH=$HOME/.basher/cellar/packages
        if [ "${PATH#*$BASHER_ROOT/cellar/bin}" = "${PATH}" ]; then
        export PATH="$BASHER_ROOT/cellar/bin:$PATH"
        fi
        . "$BASHER_ROOT/lib/include.zsh"
        . "$BASHER_ROOT/completions/basher.zsh"
        fpath=("$BASHER_ROOT/cellar/completions/zsh/compsys" $fpath)
        for f in $(command ls "$BASHER_ROOT/cellar/completions/zsh/compctl"); do source "$BASHER_ROOT/cellar/completions/zsh/compctl/$f"; done
    elif [ -n "$BASH_VERSION" ]; then
        # basher init - bash | sed "s:$HOME:\$HOME:g" | pbcopy
        export BASHER_SHELL=bash
        export BASHER_ROOT=$HOME/.basher
        export BASHER_PREFIX=$HOME/.basher/cellar
        export BASHER_PACKAGES_PATH=$HOME/.basher/cellar/packages
        if [ "${PATH#*$BASHER_ROOT/cellar/bin}" = "${PATH}" ]; then
        export PATH="$BASHER_ROOT/cellar/bin:$PATH"
        fi
        . "$BASHER_ROOT/lib/include.bash"
        . "$BASHER_ROOT/completions/basher.bash"
        for f in $(command ls "$BASHER_ROOT/cellar/completions/bash"); do source "$BASHER_ROOT/cellar/completions/bash/$f"; done
    fi
    path_append_all "$BASHER_ROOT"
    path_append_all "$BASHER_PREFIX"
}

mu_basher () {
    unset BASHER_SHELL
    unset BASHER_ROOT
    unset BASHER_PREFIX
    unset BASHER_PACKAGES_PATH
}

# go
ml_go () {
    path_append_all "$HOME/go"
}

# sman
ml_s () {
    . "$HOME/.sman/sman.rc"
    export SMAN_APPEND_HISTORY=false
    export SMAN_EXEC_CONFIRM=false
    export SMAN_SNIPPET_DIR="$HOME/git/source/sman-snippets"
}

mu_s () {
    unset SMAN_APPEND_HISTORY
    unset SMAN_EXEC_CONFIRM
    unset SMAN_SNIPPET_DIR
}

ml_exa () {
    alias ls=exa
}

mu_exa () {
    alias ls="noglob ls"
}

ml_cg () {
    path_append_all "$CARGO_PREFIX"
}

ml_ghcup () {
    # See `cat ~/.ghcup/env`.
    path_append_all "$HOME/.cabal"
    path_append_all "$HOME/.ghcup"
}

# hosts ========================================================================

if [[ -n "$NERSC_HOST" ]]; then
    ml_host () {
        # common polar
        export PBCOMMON="$COMMON_ROOT/polar"
        path_prepend_all "$PBCOMMON/local"
    }

    mu_host () {
        unset PBCOMMON
    }

    ml_toast () {
        module use /global/common/software/polar/.conda/envs/cmbenv/modulefiles
        # module use /global/common/software/cmb/cori/default/modulefiles
        module load cmbenv
        # manually edit /global/common/software/polar/.conda/envs/cmbenv/modulefiles/cmbenv/v1.0.3.dev124
        # to remove PATH editing, sqs alias, PYTHONSTARTUP, PYTHONUSERBASE
        # manual edit /global/common/software/polar/.conda/envs/cmbenv/cmbenv_python/bin/cmbenv
        # to fix zsh error
        . /global/common/software/polar/.conda/envs/cmbenv/cmbenv_python/bin/cmbenv
    }

    ml_toast_conda () {
        TOAST_PREFIX=/global/common/software/polar/.conda/envs/common-20210404-toast-conda
        conda activate "$TOAST_PREFIX"
    }
elif [[ -n "$JBCA_HOST" && -n "$SCRATCH" ]]; then
    ml_host () {
        path_prepend_all "$SCRATCH/.local"
    }
else
    case "$__HOST" in
        gordita)
            ml_host () {
                [[ "$__HOST" == gordita ]] && path_prepend_all "$HOME/.linux.local"
            }

            mu_host () {
                true
            }
            ;;
        *)
            # just to make sure it always exists
            ml_host () {}
            ml_toast_gnu () {
                TOAST_PREFIX="$SCRATCH/local/toast-gnu"
                conda activate "$TOAST_PREFIX/conda"
                [[ $__UNAME == Darwin ]] && ld_library_path_prepend /opt/local/lib/mpich-mp
                ld_library_path_prepend "$TOAST_PREFIX/compile/lib"
                pythonpath_prepend "$TOAST_PREFIX/compile/lib/python3.8/site-packages"
                path_prepend "$TOAST_PREFIX/compile/bin:$TOAST_PREFIX/conda/bin"
            }

            ml_toast_conda () {
                conda activate toast-conda
            }
            ;;
    esac
fi

#===============================================================================

ml_clean () {
    # special case, may generalize something like this to any FreeBSD?
    [[ "$__HOST" == bolo ]] && export PATH="$PATH:$HOME/.freebsd.local/gopath/bin"

    # go
    path_append_all "$HOME/gopath"
    export GOPATH="$HOME/go"
    export GOBIN="$HOME/go/bin"

    # * load minimal environment for interactive use
    path_prepend_all "$HOME/.local"

    [[ -f "$HOME/.sman/sman.rc" ]] && ml_s
    # exa: only alias if exist. hash is incorrect on Cori
    type exa >/dev/null 2>&1 && ml_exa
}

ml () {
    # * load all installed environments
    # * includes clean, go, ghcup, brew, port, conda, cargo, basher, host
    ml_go
    ml_ghcup
    [[ -n "$HOMEBREW_PREFIX" ]] && ml_brew
    [[ "$__OSTYPE" == darwin ]] && ml_port
    [[ -n "$__CONDA_PREFIX" ]] && ml_conda
    [[ -n "$CARGO_PREFIX" ]] && ml_cg
    [[ -d "$HOME/.basher" ]] && ml_basher

    ml_host

    ml_clean
}

mu () {
    if [[ -n "$__PATH" ]]; then
        export PATH="$__PATH"
    else
        unset PATH
    fi
    if [[ -n "$__MANPATH" ]]; then
        export MANPATH="$__MANPATH"
    else
        unset MANPATH
    fi
    if [[ -n "$__INFOPATH" ]]; then
        export INFOPATH="$__INFOPATH"
    else
        unset INFOPATH
    fi
    if [[ -n "$__PYTHONPATH" ]]; then
        export PYTHONPATH="$__PYTHONPATH"
    else
        unset PYTHONPATH
    fi
    if [[ -n "$__LD_LIBRARY_PATH" ]]; then
        export LD_LIBRARY_PATH="$__LD_LIBRARY_PATH"
    else
        unset LD_LIBRARY_PATH
    fi

    mu_brew
    mu_conda
    mu_s
    mu_exa
    mu_basher
    case "$__HOST" in
        cori|perlmutter) mu_host;;
    esac
}

mkdir_xdg () {
    [[ -n "$XDG_DATA_HOME" ]] && mkdir -p "$XDG_DATA_HOME"
    [[ -n "$XDG_STATE_HOME" ]] && mkdir -p "$XDG_STATE_HOME"
    [[ -n "$XDG_CONFIG_HOME" ]] && mkdir -p "$XDG_CONFIG_HOME"
    [[ -n "$XDG_CACHE_HOME" ]] && mkdir -p "$XDG_CACHE_HOME"
    # see https://docs.astropy.org/en/stable/config/index.html#getting-started
    [[ ! -d "$XDG_CONFIG_HOME/astropy" ]] && mkdir -p "$XDG_CONFIG_HOME/astropy"
    [[ ! -d "$XDG_CACHE_HOME/astropy" ]] && mkdir -p "$XDG_CACHE_HOME/astropy"
}

# main #########################################################################

if [[ -n "$__CLEAN" ]]; then
    ml_clean
else
    ml
fi

# even if this doesn't mask the world readability
# the parent directories should protect it already
umask 022

# git external diff
# $PATH is not fully set in zshenv so we have to put it here
command -v difft >/dev/null 2>&1 && export GIT_EXTERNAL_DIFF=difft

neofetch 2>/dev/null
